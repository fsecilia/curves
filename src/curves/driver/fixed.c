// SPDX-License-Identifier: GPL-2.0+ OR MIT
/*
 * The math in this module is primarily based on minimax approximations, which
 * are polynomial functions that minimize the error of an approximation over a
 * specific range. Calculating approximations with them is reasonably
 * efficient, but determining their coefficients is nontrivial; the process
 * runs Chubuchev polynomials through a truncation-aware Remez exchange
 * algorithm. To manage this, they were generated by a open source, academic
 * tool called Sollya. The scripts used to generate the coefficients are listed
 * next to the coefficients themselves.
 *
 * Copyright (C) 2025 Frank Secilia
 * Author: Frank Secilia <frank.secilia@gmail.com>
 */

#include "fixed.h"

extern curves_fixed_t curves_const_1(unsigned int frac_bits);
extern curves_fixed_t curves_const_e(unsigned int frac_bits);
extern curves_fixed_t curves_const_ln2(unsigned int frac_bits);
extern curves_fixed_t curves_const_pi(unsigned int frac_bits);

extern curves_fixed_t curves_fixed_from_integer(unsigned int frac_bits,
						int64_t value);
extern int64_t curves_fixed_to_integer(unsigned int frac_bits,
				       curves_fixed_t value);

extern curves_fixed_t curves_fixed_multiply(unsigned int multiplicand_frac_bits,
					    curves_fixed_t multiplicand,
					    unsigned int multiplier_frac_bits,
					    curves_fixed_t multiplier,
					    unsigned int output_frac_bits);

extern curves_fixed_t curves_fixed_divide(unsigned int dividend_frac_bits,
					  curves_fixed_t dividend,
					  unsigned int divisor_frac_bits,
					  curves_fixed_t divisor,
					  unsigned int output_frac_bits);

curves_fixed_t __cold __curves_fixed_multiply_error(curves_fixed_t multiplicand,
						    curves_fixed_t multiplier,
						    int shift)
{
	// Right shift tends towards 0 in the limit, so return 0.
	if (shift < 0)
		return 0;

	// 0 stays 0.
	if (multiplicand == 0 || multiplier == 0)
		return 0;

	// This is a large left shift. Saturate based on sign of product.
	return (multiplicand > 0) == (multiplier > 0) ? INT64_MAX : INT64_MIN;
}

curves_fixed_t __cold __curves_fixed_divide_error(curves_fixed_t dividend,
						  curves_fixed_t divisor,
						  int shift)
{
	// 0 dividend stays 0, even for divide by 0.
	if (dividend == 0)
		return 0;

	// Handle dividing by 0.
	if (divisor == 0) {
		// Saturate based on sign of dividend.
		return dividend > 0 ? INT64_MAX : INT64_MIN;
	}

	// Right shift tends towards 0 in the limit, so return 0.
	if (shift < 0) {
		return 0;
	}

	// This is a large left shift. Saturate based on sign of quotient.
	return (dividend > 0) == (divisor > 0) ? INT64_MAX : INT64_MIN;
}

curves_fixed_t __curves_fixed_divide(curves_fixed_t dividend,
				     curves_fixed_t divisor, int shift)
{
	if (shift >= 0) {
		// Overflow check without shifting dividend first
		int threshold_shift = 63 - shift;
		int128_t threshold_pos, threshold_neg;

		if (threshold_shift >= 0) {
			// 0 <= shift < 63: threshold is divisor << (63-shift)
			threshold_pos = (int128_t)divisor << threshold_shift;
		} else {
			// shift >= 63: threshold is divisor >> (shift-63)
			// This is a 64-bit right shift - very cheap!
			threshold_pos = divisor >> -threshold_shift;
		}
		threshold_neg = -threshold_pos;

		// Same overflow logic
		if (divisor > 0) {
			if (dividend >= threshold_pos)
				return INT64_MAX;
			if (dividend < threshold_neg)
				return INT64_MIN;
		} else {
			if (dividend > threshold_neg)
				return INT64_MIN;
			if (dividend <= threshold_pos)
				return INT64_MAX;
		}

		// Now safe to shift and divide
		int128_t shifted_dividend = (int128_t)dividend << shift;
		return curves_div_s128_by_s64(shifted_dividend, divisor);
	} else {
		// Divide first with relaxed overflow threshold, then right shift
		int128_t threshold_pos = (int128_t)divisor << (63 + shift);
		int128_t threshold_neg = -threshold_pos;

		if (divisor > 0) {
			if (dividend >= threshold_pos)
				return INT64_MAX >> -shift;
			if (dividend < threshold_neg)
				return INT64_MIN >> -shift;
		} else {
			if (dividend > threshold_neg)
				return INT64_MIN >> -shift;
			if (dividend <= threshold_pos)
				return INT64_MAX >> -shift;
		}

		int64_t quotient = curves_div_s128_by_s64(dividend, divisor);
		return quotient >> -shift;
	}
}
