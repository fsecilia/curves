// SPDX-License-Identifier: GPL-2.0+ OR MIT
/*
 * The math in this module is primarily based on minimax approximations, which
 * are polynomial functions that minimize the error of an approximation over a
 * specific range. Calculating approximations with them is reasonably
 * efficient, but determining their coefficients is nontrivial; the process
 * runs Chubuchev polynomials through a truncation-aware Remez exchange
 * algorithm. To manage this, they were generated by a open source, academic
 * tool called Sollya. The scripts used to generate the coefficients are listed
 * next to the coefficients themselves.
 *
 * Copyright (C) 2025 Frank Secilia
 * Author: Frank Secilia <frank.secilia@gmail.com>
 */

#include "fixed.h"

extern curves_fixed_t curves_const_1(unsigned int frac_bits);
extern curves_fixed_t curves_const_e(unsigned int frac_bits);
extern curves_fixed_t curves_const_ln2(unsigned int frac_bits);
extern curves_fixed_t curves_const_pi(unsigned int frac_bits);

extern curves_fixed_t curves_fixed_from_integer(unsigned int frac_bits,
						int64_t value);
extern int64_t curves_fixed_to_integer(unsigned int frac_bits,
				       curves_fixed_t value);

extern curves_fixed_t curves_fixed_multiply(unsigned int multiplicand_frac_bits,
					    curves_fixed_t multiplicand,
					    unsigned int multiplier_frac_bits,
					    curves_fixed_t multiplier,
					    unsigned int output_frac_bits);

extern curves_fixed_t curves_fixed_divide(unsigned int dividend_frac_bits,
					  curves_fixed_t dividend,
					  unsigned int divisor_frac_bits,
					  curves_fixed_t divisor,
					  unsigned int output_frac_bits);

curves_fixed_t __cold __curves_fixed_multiply_error(curves_fixed_t multiplicand,
						    curves_fixed_t multiplier,
						    int shift)
{
	// Right shift tends towards 0 in the limit, so return 0.
	if (shift < 0)
		return 0;

	// 0 stays 0.
	if (multiplicand == 0 || multiplier == 0)
		return 0;

	// This is a large left shift. Saturate based on sign of product.
	return (multiplicand > 0) == (multiplier > 0) ? INT64_MAX : INT64_MIN;
}

static inline curves_fixed_t saturate(bool result_positive)
{
	return result_positive ? INT64_MAX : INT64_MIN;
}

static inline curves_fixed_t try_saturate(curves_fixed_t dividend,
					  curves_fixed_t divisor,
					  int128_t threshold_pos,
					  int128_t threshold_neg)
{
	if (divisor > 0) {
		if (dividend >= threshold_pos)
			return saturate(true);
		if (dividend < threshold_neg)
			return saturate(false);
	} else {
		if (dividend > threshold_neg)
			return saturate(false);
		if (dividend <= threshold_pos)
			return saturate(true);
	}

	return 0;
}

curves_fixed_t __cold __curves_fixed_divide_error(curves_fixed_t dividend,
						  curves_fixed_t divisor,
						  int shift)
{
	// 0 dividend stays 0, even for divide by 0.
	if (dividend == 0)
		return 0;

	// Handle dividing by 0.
	if (divisor == 0) {
		return saturate(dividend > 0);
	}

	// Right shift tends towards 0 in the limit, so return 0.
	if (shift < 0) {
		return 0;
	}

	// This is a large left shift. Saturate based on sign of quotient.
	return saturate((dividend > 0) == (divisor > 0));
}

curves_fixed_t __curves_fixed_divide_lshift(curves_fixed_t dividend,
					    curves_fixed_t divisor, int shift,
					    int threshold_shift)
{
	int128_t threshold_pos, threshold_neg;
	int64_t saturation;

	if (threshold_shift >= 0) {
		// 0 <= shift < 63: threshold is divisor << (63-shift)
		threshold_pos = (int128_t)divisor << threshold_shift;
	} else {
		// shift >= 63: threshold is divisor >> (shift-63)
		// This is a 64-bit right shift - very cheap!
		threshold_pos = divisor >> -threshold_shift;
	}
	threshold_neg = -threshold_pos;

	saturation =
		try_saturate(dividend, divisor, threshold_pos, threshold_neg);
	if (saturation != 0)
		return saturation;

	// Now safe to shift and divide
	return curves_div_s128_by_s64((int128_t)dividend << shift, divisor);
}

curves_fixed_t __curves_fixed_divide_rshift(curves_fixed_t dividend,
					    curves_fixed_t divisor, int shift)
{
	// Divide first with relaxed overflow threshold, then right shift
	int128_t threshold_pos = (int128_t)divisor << (63 + shift);
	int128_t threshold_neg = -threshold_pos;
	int64_t saturation =
		try_saturate(dividend, divisor, threshold_pos, threshold_neg);

	if (saturation != 0)
		return saturation >> -shift;

	return curves_div_s128_by_s64(dividend, divisor) >> -shift;
}
