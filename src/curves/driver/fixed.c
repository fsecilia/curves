// SPDX-License-Identifier: GPL-2.0+ OR MIT
/*
 * The math in this module is primarily based on minimax approximations, which
 * are polynomial functions that minimize the error of an approximation over a
 * specific range. Calculating approximations with them is reasonably
 * efficient, but determining their coefficients is nontrivial; the process
 * runs Chubuchev polynomials through a truncation-aware Remez exchange
 * algorithm. To manage this, they were generated by a open source, academic
 * tool called Sollya. The scripts used to generate the coefficients are listed
 * next to the coefficients themselves.
 *
 * Copyright (C) 2025 Frank Secilia
 * Author: Frank Secilia <frank.secilia@gmail.com>
 */

#include "fixed.h"

extern curves_fixed_t curves_const_1(unsigned int frac_bits);
extern curves_fixed_t curves_const_e(unsigned int frac_bits);
extern curves_fixed_t curves_const_ln2(unsigned int frac_bits);
extern curves_fixed_t curves_const_pi(unsigned int frac_bits);

extern curves_fixed_t curves_fixed_from_integer(unsigned int frac_bits,
						int64_t value);
extern int64_t curves_fixed_to_integer(unsigned int frac_bits,
				       curves_fixed_t value);

extern curves_fixed_t curves_fixed_multiply(unsigned int multiplicand_frac_bits,
					    curves_fixed_t multiplicand,
					    unsigned int multiplier_frac_bits,
					    curves_fixed_t multiplier,
					    unsigned int output_frac_bits);

extern curves_fixed_t curves_fixed_divide(unsigned int dividend_frac_bits,
					  curves_fixed_t dividend,
					  unsigned int divisor_frac_bits,
					  curves_fixed_t divisor,
					  unsigned int output_frac_bits);

curves_fixed_t __cold __curves_fixed_multiply_error(curves_fixed_t multiplicand,
						    curves_fixed_t multiplier,
						    int shift)
{
	// Right shift tends towards 0 in the limit, so return 0.
	if (shift < 0)
		return 0;

	// 0 stays 0.
	if (multiplicand == 0 || multiplier == 0)
		return 0;

	// This is a large left shift. Saturate based on sign of product.
	return (multiplicand > 0) == (multiplier > 0) ? INT64_MAX : INT64_MIN;
}

static inline curves_fixed_t saturate(bool result_positive)
{
	return result_positive ? INT64_MAX : INT64_MIN;
}

static inline curves_fixed_t try_saturate(curves_fixed_t dividend,
					  curves_fixed_t divisor,
					  int128_t threshold)
{
	int128_t dividend_magnitude = dividend;
	int128_t threshold_magnitude = threshold;

	if (dividend_magnitude < 0)
		dividend_magnitude = -dividend_magnitude;

	if (threshold_magnitude < 0)
		threshold_magnitude = -threshold_magnitude;

	if (dividend_magnitude >= threshold_magnitude) {
		// Saturate based on sign of quotient.
		return saturate((dividend ^ divisor) >= 0);
	}

	return 0;
}

curves_fixed_t __cold __curves_fixed_divide_error(curves_fixed_t dividend,
						  curves_fixed_t divisor,
						  int shift)
{
	// 0 dividend stays 0, even for divide by 0.
	if (dividend == 0)
		return 0;

	// Handle dividing by 0.
	if (divisor == 0)
		return saturate(dividend > 0);

	// Right shift tends towards 0 in the limit, so return 0.
	if (shift < 0)
		return 0;

	// This is a large left shift. Saturate based on sign of quotient.
	return saturate((dividend > 0) == (divisor > 0));
}

curves_fixed_t __curves_fixed_divide_lshift(curves_fixed_t dividend,
					    curves_fixed_t divisor, int shift,
					    int saturation_threshold_bit)
{
	int128_t saturation_threshold;
	int64_t saturation;

	if (saturation_threshold_bit >= 0) {
		// 128-bit shift
		saturation_threshold = (int128_t)divisor
				       << saturation_threshold_bit;
	} else {
		// 64-bit shift
		saturation_threshold =
			(int128_t)(divisor >> -saturation_threshold_bit);
	}

	saturation = try_saturate(dividend, divisor, saturation_threshold);
	if (saturation != 0)
		return saturation;

	return curves_div_s128_by_s64((int128_t)dividend << shift, divisor);
}

curves_fixed_t __curves_fixed_divide_rshift(curves_fixed_t dividend,
					    curves_fixed_t divisor, int shift,
					    int saturation_threshold_bit)
{
	int128_t saturation_threshold = (int128_t)divisor
					<< saturation_threshold_bit;
	int64_t saturation =
		try_saturate(dividend, divisor, saturation_threshold);

	if (saturation != 0)
		return saturation >> -shift;

	return curves_div_s128_by_s64(dividend, divisor) >> -shift;
}
