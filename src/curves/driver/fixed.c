// SPDX-License-Identifier: GPL-2.0+ OR MIT
/*
 * The math in this module is primarily based on minimax approximations, which
 * are polynomial functions that minimize the error of an approximation over a
 * specific range. Calculating approximations with them is reasonably
 * efficient, but determining their coefficients is nontrivial; the process
 * runs Chubuchev polynomials through a truncation-aware Remez exchange
 * algorithm. To manage this, they were generated by a open source, academic
 * tool called Sollya. The scripts used to generate the coefficients are listed
 * next to the coefficients themselves.
 *
 * Copyright (C) 2025 Frank Secilia
 * Author: Frank Secilia <frank.secilia@gmail.com>
 */

#include "fixed.h"

// ----------------------------------------------------------------------------
// 64-bit API
// ----------------------------------------------------------------------------

extern s64 curves_saturate_s64(bool result_positive);

s64 __cold __curves_fixed_rescale_error_s64(s64 value, unsigned int frac_bits,
					    unsigned int output_frac_bits)
{
	// Zero values and right shifts return 0.
	if (value == 0 || output_frac_bits < frac_bits)
		return 0;

	// Left shifts that would overflow saturate based on sign.
	return curves_saturate_s64(value >= 0);
}

extern s64 __curves_fixed_shr_rtz_s64(s64 value, unsigned int shift);
extern s64 __curves_fixed_shl_sat_s64(s64 value, unsigned int shift);
extern s64 curves_fixed_rescale_s64(s64 value, unsigned int frac_bits,
				    unsigned int output_frac_bits);

// ----------------------------------------------------------------------------
// 128-bit API
// ----------------------------------------------------------------------------

extern s128 curves_saturate_s128(bool result_positive);

s128 __cold __curves_fixed_rescale_error_s128(s128 value,
					      unsigned int frac_bits,
					      unsigned int output_frac_bits)
{
	// Zero values and right shifts return 0.
	if (value == 0 || output_frac_bits < frac_bits)
		return 0;

	// Left shifts that would overflow saturate based on sign.
	return curves_saturate_s128(value >= 0);
}

extern s128 __curves_fixed_shr_rtz_s128(s128 value, unsigned int shift);
extern s128 __curves_fixed_shl_sat_s128(s128 value, unsigned int shift);
extern s128 curves_fixed_rescale_s128(s128 value, unsigned int frac_bits,
				      unsigned int output_frac_bits);
extern s64 curves_fixed_narrow_s128_s64(s128 value);

// ----------------------------------------------------------------------------
// Common API
// ----------------------------------------------------------------------------

extern s64 curves_fixed_from_integer(s64 value, unsigned int frac_bits);
extern s64 curves_fixed_to_integer(s64 value, unsigned int frac_bits);

extern s64 curves_fixed_const_1(unsigned int frac_bits);
extern s64 curves_fixed_const_e(unsigned int frac_bits);
extern s64 curves_fixed_const_ln2(unsigned int frac_bits);
extern s64 curves_fixed_const_pi(unsigned int frac_bits);

extern s64 curves_fixed_multiply(s64 multiplicand,
				 unsigned int multiplicand_frac_bits,
				 s64 multiplier,
				 unsigned int multiplier_frac_bits,
				 unsigned int output_frac_bits);

s64 __cold __curves_fixed_divide_error(s64 dividend, s64 divisor, int shift)
{
	// Zero dividend always produces zero.
	if (dividend == 0)
		return 0;

	// Division by zero saturates based on dividend sign.
	if (divisor == 0)
		return curves_saturate_s64(dividend >= 0);

	// Excessive right shift causes underflow to zero.
	if (shift <= -64)
		return 0;

	// All other cases (invalid parameters, excessive left shift) saturate.
	return curves_saturate_s64((dividend ^ divisor) >= 0);
}

extern s64 __curves_fixed_divide_try_saturate(s64 dividend, s64 divisor,
					      int shift);
extern s64 __curves_fixed_divide_try_saturate_shl(s64 dividend, s64 divisor,
						  int saturation_threshold_bit);
extern s64 __curves_fixed_divide_try_saturate_shr(s64 dividend, s64 divisor,
						  int saturation_threshold_bit);
extern s64 curves_fixed_divide(s64 dividend, unsigned int dividend_frac_bits,
			       s64 divisor, unsigned int divisor_frac_bits,
			       unsigned int output_frac_bits);
