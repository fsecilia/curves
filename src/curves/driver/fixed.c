// SPDX-License-Identifier: GPL-2.0+ OR MIT
/*
 * The math in this module is primarily based on minimax approximations, which
 * are polynomial functions that minimize the error of an approximation over a
 * specific range. Calculating approximations with them is reasonably
 * efficient, but determining their coefficients is nontrivial; the process
 * runs Chubuchev polynomials through a truncation-aware Remez exchange
 * algorithm. To manage this, they were generated by a open source, academic
 * tool called Sollya. The scripts used to generate the coefficients are listed
 * next to the coefficients themselves.
 *
 * Copyright (C) 2025 Frank Secilia
 * Author: Frank Secilia <frank.secilia@gmail.com>
 */

#include "fixed.h"

// ----------------------------------------------------------------------------
// s64 rescaler
// ----------------------------------------------------------------------------

s64 __cold __curves_fixed_rescale_error_s64(s64 value, unsigned int frac_bits,
					    unsigned int output_frac_bits)
{
	// Zero values and right shifts return 0.
	if (value == 0 || output_frac_bits < frac_bits)
		return 0;

	// Left shifts that would overflow saturate based on sign.
	return curves_saturate_s64(value >= 0);
}

extern s64 __curves_fixed_shr_rtz_s64(s64 value, unsigned int shift);
extern s64 __curves_fixed_shl_sat_s64(s64 value, unsigned int shift);
extern s64 curves_fixed_rescale_s64(s64 value, unsigned int frac_bits,
				    unsigned int output_frac_bits);

// ----------------------------------------------------------------------------
// s128 rescaler
// ----------------------------------------------------------------------------

s128 __cold __curves_fixed_rescale_error_s128(s128 value,
					      unsigned int frac_bits,
					      unsigned int output_frac_bits)
{
	// Zero values and right shifts return 0.
	if (value == 0 || output_frac_bits < frac_bits)
		return 0;

	// Left shifts that would overflow saturate based on sign.
	return curves_saturate_s128(value >= 0);
}

extern s128 __curves_fixed_shr_rtz_s128(s128 value, unsigned int shift);
extern s128 __curves_fixed_shl_sat_s128(s128 value, unsigned int shift);
extern s128 curves_fixed_rescale_s128(s128 value, unsigned int frac_bits,
				      unsigned int output_frac_bits);

// ----------------------------------------------------------------------------
// u64 rescaler
// ----------------------------------------------------------------------------

u64 __cold __curves_fixed_rescale_error_u64(u64 value, unsigned int frac_bits,
					    unsigned int output_frac_bits)
{
	// Zero values and right shifts return 0.
	if (value == 0 || output_frac_bits < frac_bits)
		return 0;

	return U64_MAX;
}

extern u64 __curves_fixed_shr_rtz_u64(u64 value, unsigned int shift);
extern u64 __curves_fixed_shl_sat_u64(u64 value, unsigned int shift);
extern u64 curves_fixed_rescale_u64(u64 value, unsigned int frac_bits,
				    unsigned int output_frac_bits);

// ----------------------------------------------------------------------------
// u128 rescaler
// ----------------------------------------------------------------------------

u128 __cold __curves_fixed_rescale_error_u128(u128 value,
					      unsigned int frac_bits,
					      unsigned int output_frac_bits)
{
	// Zero values and right shifts return 0.
	if (value == 0 || output_frac_bits < frac_bits)
		return 0;

	return CURVES_U128_MAX;
}

extern u128 __curves_fixed_shr_rtz_u128(u128 value, unsigned int shift);
extern u128 __curves_fixed_shl_sat_u128(u128 value, unsigned int shift);
extern u128 curves_fixed_rescale_u128(u128 value, unsigned int frac_bits,
				      unsigned int output_frac_bits);

// ----------------------------------------------------------------------------
// Common API
// ----------------------------------------------------------------------------

extern s64 curves_fixed_from_integer(s64 value, unsigned int frac_bits);
extern s64 curves_fixed_to_integer(s64 value, unsigned int frac_bits);

extern s64 curves_fixed_const_1(unsigned int frac_bits);
extern s64 curves_fixed_const_e(unsigned int frac_bits);
extern s64 curves_fixed_const_ln2(unsigned int frac_bits);
extern s64 curves_fixed_const_pi(unsigned int frac_bits);

s64 __cold __curves_fixed_add_error(unsigned int augend_frac_bits,
				    unsigned int addend_frac_bits,
				    unsigned int output_frac_bits)
{
	WARN_ONCE(1,
		  "curves_fixed_add: invalid frac_bits "
		  "(augend=%u, addend=%u, output=%u)\n",
		  augend_frac_bits, addend_frac_bits, output_frac_bits);

	return 0;
}

extern s64 curves_fixed_add(s64 augend, unsigned int augend_frac_bits,
			    s64 addend, unsigned int addend_frac_bits,
			    unsigned int output_frac_bits);

s64 __cold __curves_fixed_subtract_error(unsigned int minuend_frac_bits,
					 unsigned int subtrahend_frac_bits,
					 unsigned int output_frac_bits)
{
	WARN_ONCE(1,
		  "curves_fixed_subtract: invalid frac_bits "
		  "(minuend=%u, subtrahend=%u, output=%u)\n",
		  minuend_frac_bits, subtrahend_frac_bits, output_frac_bits);

	return 0;
}

extern s64 curves_fixed_multiply(s64 multiplicand,
				 unsigned int multiplicand_frac_bits,
				 s64 multiplier,
				 unsigned int multiplier_frac_bits,
				 unsigned int output_frac_bits);

static inline s64
curves_fixed_fma(s64 multiplicand, unsigned int multiplicand_frac_bits,
		 s64 multiplier, unsigned int multiplier_frac_bits, s64 addend,
		 unsigned int addend_frac_bits, unsigned int output_frac_bits);

s64 __cold __curves_fixed_divide_error(s64 dividend, s64 divisor)
{
	// 0 dividend always produces 0.
	if (dividend == 0)
		return 0;

	// Division by zero saturates based on dividend sign.
	if (divisor == 0)
		return curves_saturate_s64(dividend >= 0);

	// Saturate based on the sign of the quotient (dividend ^ divisor)
	return curves_saturate_s64((dividend ^ divisor) >= 0);
}

extern int __curves_fixed_divide_optimal_shift(u64 dividend, u64 divisor);
extern u64 __curves_fixed_divide_shr_rne(u64 quotient, u64 remainder,
					 unsigned int shift);
extern u64 __curves_fixed_divide_rne_exact(u64 quotient, u64 remainder,
					   u64 divisor);
extern s64 curves_fixed_divide(s64 dividend, unsigned int dividend_frac_bits,
			       s64 divisor, unsigned int divisor_frac_bits,
			       unsigned int output_frac_bits);

extern u64 curves_fixed_isqrt(u64 x, unsigned int frac_bits,
			      unsigned int output_frac_bits);

extern u64 curves_fixed_exp2(s64 x, unsigned int frac_bits,
			     unsigned int output_frac_bits);

extern s64
__curves_fixed_log2_eval_poly(unsigned int output_frac_bits, int poly_degree,
			      s64 int_scaled, u64 frac_part_norm,
			      const s64 *poly_coeffs,
			      const unsigned int *poly_coeff_frac_bits);
extern s64 curves_fixed_log2(u64 x, unsigned int x_frac_bits,
			     unsigned int output_frac_bits);

extern s64 approx_log2_q32(s64 x);
