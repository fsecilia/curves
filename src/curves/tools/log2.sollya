/*
  SPDX-License-Identifier: MIT

  This script generates both the coefficients and their frac_bits for log2.
*/

// Use high precision internals.
prec = 512!;

procedure calc_degree(f, domain) {
  var target_accuracy, degree_interval;

  // Determine degree based on accuracy.
  target_accuracy = 1b-61;
  degree_interval = guessdegree(f, domain, target_accuracy, 1, 25);
  return sup(degree_interval);
};

procedure calc_formats(f, domain, poly_degree) {
  var poly_remez, formats, i, c, int_bits, frac_bits;

  // Use remez() to get initial floating-point coefficients.
  poly_remez = remez(f, poly_degree, domain);

  // Analyze coefficients to determine optimal fixed-point formats. Figure out
  // how many integer bits we need for each and allocate the rest to fractional
  // bits (up to Q64 total).
  formats = [||];
  for i from 0 to poly_degree do {
    c = coeff(poly_remez, i);

    // Find coefficient's magnitude.
    if (c == 0) then {
      int_bits = 0;
    } else {
      int_bits = ceil(log2(abs(c))) + 1;
    };

    // Allocate remaining bits to fractional part
    frac_bits = 64 - int_bits;

    // Append optimal format to list of formats.
    formats = formats :. frac_bits;
  };

  return formats;
};

procedure create_poly(f, domain, poly_degree, formats) {
  return fpminimax(f, poly_degree, formats, domain, fixed, absolute);
};

procedure print_poly(poly_fixed, formats, coeffs_label, frac_bits_label) {
  var poly_degree, i, c, c_rounded;

  poly_degree = degree(poly_fixed);

  print("s64", coeffs_label, "[] = {");
  for i from 0 to poly_degree do {
    c = coeff(poly_fixed, i);
    c_rounded = nearestint(c*2^formats[i]);
    print(c_rounded, ",");
  };
  print("};");

  print("unsigned int", frac_bits_label, "[] = {");
  for i from 0 to poly_degree do {
    print(formats[i], ",");
  };
  print("};");
};

f = log2(x + 1);
partition_location = sqrt(2) - 1;

left_partition_domain = [0;partition_location];
left_partition_degree = calc_degree(f, left_partition_domain);
left_partition_formats = calc_formats(f, left_partition_domain, left_partition_degree);
left_partition = create_poly(f, left_partition_domain, left_partition_degree, left_partition_formats);

right_partition_domain = [partition_location;1];
right_partition_degree = calc_degree(f, right_partition_domain);
right_partition_formats = calc_formats(f, right_partition_domain, right_partition_degree);
right_partition = create_poly(f, right_partition_domain, right_partition_degree, right_partition_formats);

if (degree(left_partition) != degree(right_partition)) then {
  print("Partition poly degrees do not match!");
  error;
};
print("int poly_degree =", degree(left_partition), ";");

print("u64 partition_location_q0_64 =", nearestint(partition_location*2^64), ";");
print_poly(left_partition, left_partition_formats, "left_partition_coeffs", "left_partition_frac_bits");
print_poly(right_partition, right_partition_formats, "right_partition_coeffs", "right_partition_frac_bits");
