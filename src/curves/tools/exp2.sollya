/*
  SPDX-License-Identifier: MIT

  This script generates both the coefficients and their frac_bits for exp2.
*/

// Use high precision internals.
prec = 512!;

// Approximating 2^x over [0, 1].
f = 2^x;
domain = [0;1];

// Determine degree based on accuracy.
target_accuracy = 1b-61;
degree_interval = guessdegree(f, domain, target_accuracy, 1, 25);
poly_degree = sup(degree_interval);

// Use remez() to get initial floating-point coefficients.
poly_remez = remez(f, poly_degree, domain);

// Analyze coefficients to determine optimal fixed-point formats. Figure out
// how many integer bits we need for each and allocate the rest to fractional
// bits (up to Q64 total).
formats = [||];
for i from 0 to poly_degree do {
  c = coeff(poly_remez, i);

  // Find coefficient's magnitude.
  if (c == 0) then {
    int_bits = 0;
  } else {
    int_bits = ceil(log2(abs(c))) + 1;
  };

  // Allocate remaining bits to fractional part
  frac_bits = 64 - int_bits;

  // Append optimal format to list of formats.
  formats = formats :. frac_bits;
};

// Call fpminimax() with optimal formats.
poly_fixed = fpminimax(f, poly_degree, formats, domain, fixed, absolute);

print("int poly_degree =", poly_degree, ";");
print("u64 poly_coeffs[] = {");
for i from 0 to poly_degree do {
  c = coeff(poly_fixed, i);
  c_rounded = nearestint(c*2^formats[i]);
  print(c_rounded, ",");
};
print("};");

print("unsigned int poly_frac_bits[] = {");
for i from 0 to poly_degree do {
  print(formats[i], ",");
};
print("};");
